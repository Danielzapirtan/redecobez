<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Room View from Sketch</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff); // White background for room

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 5, 5); // Initial camera position

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Orbit controls for virtual camera browsing
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.screenSpacePanning = false;
        controls.minDistance = 1;
        controls.maxDistance = 20;

        // Lighting for semi-realistic look
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Room dimensions (based on sketch interpretation)
        // Assuming units in meters, scaled down for 3D (1 unit = 1 meter)
        // L-shaped room: long wall 3.2m, assume short arm ~2m, height 2.5m
        const roomLength = 3.2; // Main horizontal
        const roomWidth = 2.0; // Vertical arm
        const roomHeight = 2.5;
        const wallThickness = 0.1;

        // Materials
        const floorMaterial = new THREE.MeshLambertMaterial({ color: 0xdddddd }); // Light gray floor
        const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff }); // White walls
        const counterMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 }); // Brown wood counter
        const applianceMaterial = new THREE.MeshLambertMaterial({ color: 0xaaaaaa }); // Gray appliances

        // Floor (L-shape)
        const floorGeometry = new THREE.Shape();
        floorGeometry.moveTo(0, 0);
        floorGeometry.lineTo(roomLength, 0);
        floorGeometry.lineTo(roomLength, roomWidth - 1); // L bend
        floorGeometry.lineTo(roomLength - 1, roomWidth - 1); // Inner cut for L
        floorGeometry.lineTo(roomLength - 1, roomWidth);
        floorGeometry.lineTo(0, roomWidth);
        floorGeometry.lineTo(0, 0);

        const extrudeSettings = { depth: 0.01, bevelEnabled: false };
        const floor = new THREE.ExtrudeMesh(new THREE.ExtrudeGeometry(floorGeometry, extrudeSettings), floorMaterial);
        floor.rotation.x = -Math.PI / 2; // Lay flat
        floor.position.y = 0;
        scene.add(floor);

        // Walls (simplified as boxes for L-shape)
        // Back wall (horizontal)
        const backWall = new THREE.Mesh(new THREE.BoxGeometry(roomLength, roomHeight, wallThickness), wallMaterial);
        backWall.position.set(roomLength / 2, roomHeight / 2, 0);
        scene.add(backWall);

        // Left wall (vertical full)
        const leftWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, roomHeight, roomWidth), wallMaterial);
        leftWall.position.set(0, roomHeight / 2, roomWidth / 2);
        scene.add(leftWall);

        // Right wall (short, for L)
        const rightWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, roomHeight, roomWidth - 1), wallMaterial);
        rightWall.position.set(roomLength, roomHeight / 2, (roomWidth - 1) / 2);
        scene.add(rightWall);

        // Front wall segment (bottom part of L)
        const frontWallShort = new THREE.Mesh(new THREE.BoxGeometry(roomLength - 1, roomHeight, wallThickness), wallMaterial);
        frontWallShort.position.set((roomLength - 1) / 2, roomHeight / 2, roomWidth);
        scene.add(frontWallShort);

        // Inner L wall
        const innerWall = new THREE.Mesh(new THREE.BoxGeometry(1, roomHeight, wallThickness), wallMaterial);
        innerWall.position.set(roomLength - 0.5, roomHeight / 2, roomWidth - 1);
        scene.add(innerWall);

        // Furniture based on sketch labels (positions estimated)
        // Assuming layout: Washing machine left bottom, counter along bottom, oven/stove/sink/fridge along right

        // Washing machine (bottom left)
        const washer = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.9, 0.6), applianceMaterial);
        washer.position.set(0.3, 0.45, roomWidth - 0.3);
        scene.add(washer);

        // Counter (Arbeitsplatte) along bottom
        const counter = new THREE.Mesh(new THREE.BoxGeometry(roomLength - 1.2, 0.9, 0.6), counterMaterial);
        counter.position.set((roomLength - 1.2) / 2 + 0.6, 0.45, roomWidth - 0.3);
        scene.add(counter);

        // Oven (Ofen, under counter)
        const oven = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.9, 0.6), applianceMaterial);
        oven.position.set(1.0, 0.45, roomWidth - 0.3);
        scene.add(oven);

        // Stove (Herd, on counter)
        const stove = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.1, 0.6), applianceMaterial);
        stove.position.set(1.8, 0.95, roomWidth - 0.3);
        scene.add(stove);

        // Sink (Spüle, on counter)
        const sink = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.1, 0.6), applianceMaterial);
        sink.position.set(2.5, 0.95, roomWidth - 0.3);
        scene.add(sink);

        // Fridge (Kühlschrank, right end)
        const fridge = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.8, 0.6), applianceMaterial);
        fridge.position.set(roomLength - 0.3, 0.9, roomWidth - 1.7); // Positioned in the L arm
        scene.add(fridge);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>